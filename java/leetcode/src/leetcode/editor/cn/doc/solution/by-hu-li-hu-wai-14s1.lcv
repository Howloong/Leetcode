## 方法：动态规划

**思路及算法**
理解到该题是**斐波那契数列的变种**就很好做了
定义 f[n] 为同一个字母的连续长度 n 含有的组合可能数,则有
- 对于3个字母的数字有 f[n] = f[n-1] + f[n-2] + f[n-3]
- 对于4个字母的数字7、9,有 f[n] = f[n-1] + f[n-2] + f[n-3] + f[n-4]

不同数字乘积组合数即可

***Tips:***
1.用 long 保存, 加了 3/4 次, 有可能溢出
2.题中数据长度 1e5, 这里我们先预处理好 N 含有的组合可能数, 避免内层找不同的数字时重复计算

**代码**

* java

```java
class Solution {

  static int N = 100010;
  static long[] three = new long[N];
  static long[] four = new long[N];

  static int MOD = (int) 1e9 + 7;

  static {
    three[0] = 1;
    three[1] = 1;
    three[2] = 2;
    three[3] = 4;
    four[0] = 1;
    four[1] = 1;
    four[2] = 2;
    four[3] = 4;
    for (int i = 4; i < N; i++) {
      three[i] = three[i - 1] + three[i - 2] + three[i - 3];
      three[i] %= MOD;
      four[i] = four[i - 1] + four[i - 2] + four[i - 3] + four[i - 4];
      four[i] %= MOD;
    }
  }


  public int countTexts(String pressedKeys) {
    char[] cs = pressedKeys.toCharArray();
    int n = cs.length, i = 0;
    long ans = 1;
    while (i < n) {
      int j = i;
      while (j + 1 < n && cs[j] == cs[j + 1]) j++;
      boolean isFour = cs[i] == '7' | cs[i] == '9';
      long cur = isFour ? four[j - i + 1] : three[j - i + 1];
      ans = (ans * cur) % MOD;
      i = j + 1;
    }
    return (int) ans;
  }
}
```

**复杂度分析**
时间复杂度：O(N)
空间复杂度：O(N)

**结语**
如果对您有帮助，欢迎**点赞、收藏、[关注 沪里户外](/u/hu-li-hu-wai/)**，让更多的小伙伴看到，祝大家**offer多多，AC多多**！
