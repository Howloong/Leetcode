### 解题思路

今天来学一下字符串哈希

#### 主要思路

##### 思路1 直接计算对应的哈希

只需要计算左端和右端的字符串哈希是否一样，如果一样的话，说明左端和右端可以构成段式回文。
举个例子，text = "ghihelloghi",那么我们首先会计算
g的哈希值和i的哈希值，以此类推到, ghi的哈希值和ghi的哈希值，发现是一样的，那么前后的ghi就可以构成段式回文。
具体的哈希值计算方法：
对于前面的ghi而言，我们希望计算得到$g * BASE ^ 2 + h * BASE ^ 1 + i * BASE ^ 0$，其中`BASE`相当于基数，一般`BASE = 131，13331`。具体的计算就是,$p_i = p _ {i - 1} * base + s.charAt(i - 1)$即可
那么后面的ghi就显而易见了，只需要每次让对应的字符乘以对应的基数次幂即可。

有一个细节，对于中间的字符串，如果是上述例子中的`hello`，那么显然它只能单独作为一个段式回文，但是如果中间的字符串本身就是回文的，例如`abcab`的话，我们需要将这个字符分成`(ab)(c)(ab)`的形式，我们只需要判断中间的字符串是奇数个还是偶数个。如果是形如`abcab`的，那么答案就要多加1个，即加上3，如果是形如`abab`的，那么答案就是直接加2.

##### 思路2 计算全部字符串的哈希值

首先需要说明的是，对于java，没有无符号位的long，这会导致计算整个字符串的哈希值会溢出，所以需要取MOD。而对于C++而言可以直接使用unsinged long long。超出的话会自动取MOD。

我们这里直接用ull来表示，java的话需要自己取MOD，不方便书写。
我们用p[i]表示`0 ~ i`子串对应的哈希值，用h[i]表示对应位置的base，例如$h[0] = base ^ 0$,$h[i] = base ^ i$。注意p和h都是从1开始。
我们可以得到
$p_i = p_{i - 1} * BASE + s.charAt(i - 1)$
$h_i = h_{i - 1} * BASE$
当我们想计算[l ,r]区间内的哈希值时,我们只需要
`p[r] - p[r - 1] * h[l - r + 1] `即可。
具体推导过程可以自己在演草纸上推一下，比较简单，可以直接把结论记住。
所以对于本题而言，我们只需要计算出所有字符串的哈希值，然后用四个指针,l1,r1, l2, r2分别表示左端的左右指针和右端的左右指针，只需要看[l1, r1]和[l2, r2]之间的哈希值是否一样就可以了。

对于计算全部字符串哈希值的板子如下(c++)，java需要取MOD:

* 

```
int base = 131;
int N = 1005;
ull p[N],h[N];
ull get(int l, int r) {
    return p[r] - p[l - 1] * h[r - l + 1];
}

void init(string s) {
    p[0] = 0, h[0] = 1;
    for(int i = 1; i <= s.length(); i++) {
        p[i] = p[i - 1] * base + s[i] - 'a';
        h[i] = h[i - 1] * base;
    }
}

```

### 代码

* java

```java
class Solution {
    int base = 131;
    int N = 1005;
    long[] p = new long[N];
    long[] h = new long[N];
    public int longestDecomposition(String s) {
        return copy(s);

    }

    public int copy(String s) {
        int n = s.length(), hash1 = 0, hash2 = 0;      
        int tmp = 1;
        int len = n/2;
        int ans = 0;
        int maxi = 0;
        for(int i = 1;i <= len;i++){
            hash1 = hash1*base + s.charAt(i-1);
            hash2 = hash2 + s.charAt(n-i)*tmp;
            tmp = tmp*base;
            // System.out.println(hash1 + " " + s.charAt(i - 1));
            // System.out.println(hash2 + " " + s.charAt(n - i));
            if(hash1 == hash2){
                ans += 2;
                tmp = 1;
                hash1 = 0;
                hash2 = 0;
                maxi = i;
            }
        }
        if(maxi == len) ans = len*2 < n ? ans+1 : ans;
        else ans++;
        return ans;
    }
}
```

