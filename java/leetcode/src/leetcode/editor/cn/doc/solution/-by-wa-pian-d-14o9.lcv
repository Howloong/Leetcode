### 解题思路

中等的皮，hard的核。我觉得难在需要一定量人工智能编程，至少在我这种思路下是，不太容易短时间A了。不太喜欢这种问题...写起来费劲也没啥启发。坐等官方解答学习。

1. stones无序，先排序，方便后续查缺补漏。
2. 先贪心一些，`stones[l1,l2.....r2,r1]`先看最两端的数据状况。

+ 最简单的是`r1 - l1 + 1 == n`说明所有数字都是连续的，动无可动
+ 排除l1，或者排除r1看choice2 = `[l2.....r2,r1]`,choice1 = `[l1,l2.....r2]`，查看这两段之间的空格数量已经可以确定最大操作数。最大可能，最墨迹拿法，在最开始时，拿起一端，剩下数字之间空格，都可以被插入到。贴边慢慢插入。

3. 确认最小

+ 接着贪choice1，choice2这两个中如果有一个是连续无空格的。讨论剩下的一个数字距离他最近数字的距离。如果有一个空，最小就是插进来，如果超过1个空，最小就是贴着最近数字空一个放一次，放入空格一次。两次。
+ 接着贪choice1，choice2这两个中如果有一个是有一个空格的，只能将放单的数字插入。
+ 其余情况需要知道哪一个长度为数字数量的段上，包含最多的数字，最小只能往这里插满。这块`containsMax(int[] array, int size)`

### 代码

* java

```java
class Solution {
	public int[] numMovesStonesII(int[] stones) {
		Arrays.sort(stones);
		int n = stones.length;
		// stones[l1,l2.....r2,r1]
		int l1 = stones[0], l2 = stones[1], r2 = stones[n - 2], r1 = stones[n - 1];
		if (r1 - l1 + 1 == n) {// 完整连续，没有移动的余地，n个数字连续
			return new int[] { 0, 0 };
		}
		int choice1 = r2 - l1 - n + 2;// 不含最右端r1时，[l1,r2]间空格的数量。(r2 - l1 + 1) - (n-1);// 数量 - 数字数量 = 空位置数量
		int choice2 = r1 - l2 - n + 2;// 不含最左端l1时
		int ans2 = Math.max(choice1, choice2);// 最大可能，最墨迹拿法，在最开始时，拿起一端，剩下数字之间空格，都可以被墨迹到
		if (choice1 == 0) {// r1 都连上了,[l1,r2]上连续一个不差
			if (r1 - r2 == 2) {// 最后两个数中间有一个空
				return new int[] { 1, 1 };// 最小，最左拿过来塞进去，最大也是拿最左，r1拿不起来
			} else {
				return new int[] { 2, ans2 };// 超过两个空格，最小从左端拿一个在放在r2+2位置，r1放在r2+1位置，2次
			}
		} else if (choice2 == 0) {
			if (l2 - l1 == 2) {//
				return new int[] { 1, 1 };
			} else {
				return new int[] { 2, ans2 };
			}
		} else if (choice1 == 1 || choice2 == 1) {
			// [l1,r2]中间差一个
			return new int[] { 1, ans2 };// 最少把单个的插进来。最多看空位了。总能拿起最一端往空格间插入
		} else {
			// 差别大于1
			int max = this.containsMax(stones, n);// n长窗口上最多容下了多少个数字
			int ans1 = n - max;// 所有的空都能被最小方式插入
			return new int[] { ans1, ans2 };
		}
	}

	// 数字跨度size的情况下，最多能包含array上多少个数字
	private int containsMax(int[] array, int size) {
		int l = 0, r = 0, len = array.length;
		int ans = 0;
		while (r < len) {
			while (r < len && array[r] < array[l] + size) {
				r++;
			}
			ans = Math.max(ans, r - l);
			l++;
		}
		return ans;
	}
}
```

----

贪心plus问题，都挺...yue的

#### 【贪心】【排序】【双指针】

##### [中等] 870. 优势洗牌【贪心】【排序】【双指针】[[贪心 排序 双指针](https://leetcode.cn/problems/advantage-shuffle/solution/-by-wa-pian-d-gu63/)] [[870. 优势洗牌](https://leetcode.cn/problems/advantage-shuffle/)]

##### [中等] 1040. 移动石子直到连续 II【排序】【双指针】【数组】【数学】【贪心】[[排序 + 双针 + 贪心](https://leetcode.cn/problems/moving-stones-until-consecutive-ii/solution/-by-wa-pian-d-14o9/)] [[1040. 移动石子直到连续 II](https://leetcode.cn/problems/moving-stones-until-consecutive-ii/)]

##### [中等] 1877. 数组中最大数对和的最小值【贪心】【数组】【排序】【双指针】[[贪心 排序 双指针](https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/)] [[1877. 数组中最大数对和的最小值](https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/)]

##### [中等] 2007. 从双倍数组中还原原数组【贪心】【数组】【哈希表】【排序】[[排序 贪心 双针](https://leetcode.cn/problems/find-original-array-from-doubled-array/solution/2007-cong-shuang-bei-shu-zu-zhong-huan-y-7ym2/)] [[2007. 从双倍数组中还原原数组](https://leetcode.cn/problems/find-original-array-from-doubled-array/)]

##### [中等] 556. 下一个更大元素 III【数学】【双指针】【字符串】[[贪心](https://leetcode.cn/problems/next-greater-element-iii/solution/556-xia-yi-ge-geng-da-yuan-su-iii-by-wa-zqxhf/)] [[556. 下一个更大元素 III](https://leetcode.cn/problems/next-greater-element-iii/)]

