### 解题思路

昨天笔者写这题的时候也想到前缀和了
但是没想到hash记录下的优化算法
于是想到第二天自己再独立做一下

今天本能上想是一次遍历就可以做出来
但是遇到了如果被删除了的部分中有和后面再次出现的位置前缀和相等情况
链表的直接连接就会出现问题，这个地方卡了很久
后面想到当删去部分链表的时候，也需要将hash表中的元素对应再次删去
这样就不会出现以上的情况了

但是删去这部分的代码一直出现问题，卡了一个早上
看了官解等经典题解也是两次遍历，官解下也有分析我这种情况的解法
不过说太过于复杂，还是采取官解的更优化方法

但我觉得既然都到这了，那就做一个自己的版本吧！
今天早上没做出来，有bug一直导致用例不能ac
下午睡觉起来一看就调通啦！！！
做自己就好啦，大家加油！

### 代码

![image.png](https://pic.leetcode.cn/1686552953-SzGftv-image.png)

* python3

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:
        fake_head = ListNode(0)
        fake_head.next = head
        while head and head.val == 0:
            head = head.next
            fake_head.next = head
        head = fake_head
        has,total = {},0
        while head:
            total += head.val
            if total not in has:
                has[total] = head
            else:
                cur = has[total].next
                has[total].next = head.next
                ctotal = total
                while cur and cur.next != None and cur.next != head.next:
                    ctotal += cur.val
                    if ctotal in has:
                        del has[ctotal]
                    cur = cur.next
            head = head.next
        return fake_head.next
```

