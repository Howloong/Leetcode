## 单调栈

为了方便，我们令 $[left, right]$ 为 $[a, b]$。

一个容易想到的思路是使用「单调栈」。

**统计所有最大值范围在 $[a, b]$ 之间的子数组个数，可等价为统计每一个范围落在 $[a, b]$ 之间的 $nums[i]$ 作为最大值时子数组的个数。**

由此可以进一步将问题转换为：求解每个 $nums[i]$ 作为子数组最大值时，最远的合法左右端点的位置。也就是求解每一个 $nums[i]$ 左右最近一个比其“大”的位置，这可以使用「单调栈」来进行求解。

> 对于单调栈不了解的同学，可以看前置 🧀 : [【RMQ 专题】关于 RMQ 的若干解法](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247493262&idx=1&sn=2d8e192a5767b49b9a13a6192ab3b833)

**统计所有 $nums[i]$ 对答案的贡献即是最终答案，但我们忽略了「当  `nums` 存在重复元素，且该元素作为子数组最大值时，最远左右端点的边界越过重复元素时，导致重复统计子数组」的问题。**

我们不失一般性的举个 🌰 来理解（下图）：

![WechatIMG2612.png](https://pic.leetcode.cn/1669252798-kJygAC-WechatIMG2612.png)

为了消除这种重复统计，我们可以将「最远左右边界」的一端，从「严格小于」调整为「小于等于」，从而实现半开半闭的效果。

代码：

* []

```Java
class Solution {
    public int numSubarrayBoundedMax(int[] nums, int a, int b) {
        int n = nums.length, ans = 0;
        int[] l = new int[n + 10], r = new int[n + 10];
        Arrays.fill(l, -1); Arrays.fill(r, n);
        Deque<Integer> d = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            while (!d.isEmpty() && nums[d.peekLast()] < nums[i]) r[d.pollLast()] = i;
            d.addLast(i);
        }
        d.clear();
        for (int i = n - 1; i >= 0; i--) {
            while (!d.isEmpty() && nums[d.peekLast()] <= nums[i]) l[d.pollLast()] = i;
            d.addLast(i);
        }
        for (int i = 0; i < n; i++) {
            if (nums[i] < a || nums[i] > b) continue;
            ans += (i - l[i]) * (r[i] - i);
        }
        return ans;
    }
}
```

* []

```TypeScript
function numSubarrayBoundedMax(nums: number[], a: number, b: number): number {
    let n = nums.length, ans = 0
    const l = new Array<number>(n).fill(-1), r = new Array<number>(n).fill(n)
    let stk = new Array<number>()
    for (let i = 0; i < n; i++) {
        while (stk.length > 0 && nums[stk[stk.length - 1]] < nums[i]) r[stk.pop()] = i
        stk.push(i)
    }
    stk = new Array<number>()
    for (let i = n - 1; i >= 0; i--) {
        while (stk.length > 0 && nums[stk[stk.length - 1]] <= nums[i]) l[stk.pop()] = i
        stk.push(i)
    }
    for (let i = 0; i < n; i++) {
        if (nums[i] < a || nums[i] > b) continue
        ans += (i - l[i]) * (r[i] - i)
    }
    return ans
}
```

* []

```Python
class Solution:
    def numSubarrayBoundedMax(self, nums: List[int], a: int, b: int) -> int:
        n, ans = len(nums), 0
        l, r = [-1] * n, [n] * n
        stk = []
        for i in range(n):
            while stk and nums[stk[-1]] < nums[i]:
                r[stk.pop()] = i
            stk.append(i)
        stk = []
        for i in range(n - 1, -1, -1):
            while stk and nums[stk[-1]] <= nums[i]:
                l[stk.pop()] = i
            stk.append(i)
        for i in range(n):
            if a <= nums[i] <= b:
                ans += (i - l[i]) * (r[i] - i)
        return ans
        
```

* 时间复杂度：$O(n)$
* 空间复杂度：$O(n)$

---

## 模拟

除了统计「每个 $nums[i]$ 作为子数组最大值时，所能贡献的子数组个数」以外，我们还可以统计「每个 $nums[i]$ 作为子数组右端点时，所能贡献的子数组个数」。

具体的，我们从前往后处理每个 $nums[i]$，并统计其作为子数组右端点时，所能贡献的子数组个数。同时使用变量 `j` 和 `k` 分别记录最近一次满足「$nums[i]$ 范围落在 $[a, b]$ 之间」以及「$nums[i]$ 数值大于 $b$」的下标位置。

遍历过程中根据 $nums[i]$ 与规定范围 $[a, b]$ 之间的关系进行分情况讨论：

* $nums[i]$ 大于 $b$，$nums[i]$ 作为右端点，必不可能贡献合法子数组。更新 `k`；
* $nums[i]$ 小于 $a$，此时 $nums[i]$ 想作为右端点的话，子数组必须有其他满足「范围落在 $[a, b]$ 之间」的其他数，而最近一个满足要求的位置为 $j$，若有 $j > k$，说明范围在 $(k, j]$ 均能作为子数组的左端点，累加方案数 $j - k$；若有 $j < k$，说明我们无法找到任何一个左端点，使得形成的子数组满足要求（要么最值不在 $[a, b]$ 范围内，要么有 $[a, b]$ 范围内的数，但最大值又大于 `b` 值）；
* $nums[i]$ 落在范围 $[a, b]$，此时 $nums[i]$ 想作为右端点的话，只需要找到左边第一个数值大于 $b$ 的数值即可（即变量 `k`），累加方案数 $i - k$。更新 `j`。

代码：

* []

```Java
class Solution {
    public int numSubarrayBoundedMax(int[] nums, int a, int b) {
        int n = nums.length, ans = 0;
        for (int i = 0, j = -1, k = -1; i < n; i++) {
            if (nums[i] > b) {
                k = i;
            } else {
                if (nums[i] < a) {
                    if (j > k) ans += j - k;
                } else {
                    ans += i - k;
                    j = i;
                }
            }
        }
        return ans;
    }
}
```

* []

```TypeScript
function numSubarrayBoundedMax(nums: number[], a: number, b: number): number {
    let n = nums.length, ans = 0
    for (let i = 0, j = -1, k = -1; i < n; i++) {
        if (nums[i] > b) {
            k = i
        } else {
            if (nums[i] < a) {
                if (j > k) ans += j - k
            } else {
                ans += i - k
                j = i
            }
        }
    }
    return ans
}
```

* []

```Python
class Solution:
    def numSubarrayBoundedMax(self, nums: List[int], a: int, b: int) -> int:
        n, ans = len(nums), 0
        j, k = -1, -1
        for i in range(n):
            if nums[i] > b:
                k = i
            else:
                if nums[i] < a:
                    ans += j - k if j > k else 0
                else:
                    ans += i - k
                    j = i
        return ans
```

* 时间复杂度：$O(n)$
* 空间复杂度：$O(1)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://acoier.com/oimg/gzh-qrcode.webp)，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~
