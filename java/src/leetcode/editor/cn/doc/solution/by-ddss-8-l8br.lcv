> Problem: [895. 最大频率栈](https://leetcode.cn/problems/maximum-frequency-stack/description/)

[TOC]

# 思路

若是不追求$O(1)$的时间复杂度，个人感觉这道题的难度最多到中等，使用HashMap统计当前数出现的频率，全局设置index,记录此数出现时的索引，在定义一个优先队列，按照出现频率和索引排序。

时间复杂度高点，PriorityQueue push和pop的时间复杂度： $O(logN)$

# Code

* []

```Java

class FreqStack {

    Map<Integer,Integer> numMap = new HashMap<>();
    PriorityQueue<Num> queue = new PriorityQueue<>((a,b)->{
        return a.cnt == b.cnt ? b.index - a.index:b.cnt - a.cnt;
    });
    int index = 0;
    public FreqStack() {

    }

    public void push(int val) {
        numMap.put(val,numMap.getOrDefault(val,0)+1);
        queue.offer(new Num(val,numMap.get(val),index));
        index++;
    }

    public int pop() {
        Num curNum = queue.poll();
        numMap.put(curNum.val,numMap.get(curNum.val) - 1);
        if(numMap.get(curNum.val) <= 0){ // 这个可以不要
            numMap.remove(curNum.val);
        }
        return curNum.val;
    }

    class Num{
        int val;
        int cnt;
        int index;

        public Num(int val, int cnt, int index) {
            this.val = val;
            this.cnt = cnt;
            this.index = index;
        }
    }
}

/**
 * Your FreqStack object will be instantiated and called as such:
 * FreqStack obj = new FreqStack();
 * obj.push(val);
 * int param_2 = obj.pop();
 */
```

