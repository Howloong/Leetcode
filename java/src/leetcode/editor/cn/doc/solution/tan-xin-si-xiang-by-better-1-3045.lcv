可以贪心的地方：
1. 轮转后对奇数位进行累加，为保障字典序最小，实际仅考虑奇数位的首位
2. 累加数值尽量选择累加后刚好为0的(或稍微大于0的)。对于待累加的首位数字a, 可以事先计算出所有可以累加的数值集合st，再使用st.lower_bound(10 - a)即可

* 

```
class Solution {
public:
    string findLexSmallestString(string s, int a, int b) {
        // 所有可以累加的可能
       std::set<int> couldAdd;
        for (int i = 0; i < 10; ++i){
            couldAdd.insert(a * i % 10);
        }
        // 向右轮转的位移
        int movrIdx{0};
        // 最佳结果
        string result{s};
        while (true) {
            // 当前轮转的结果
            std::string cur = s.substr(movrIdx, s.length() - movrIdx) + s.substr(0, movrIdx);
            /*
                轮转后对奇数位进行累加，为保障字典序最小，实际仅考虑奇数位的首位，累加数值尽量选择累加后刚好为0的(或稍微大于0的)，lower_bound可满足要求
            */
            auto curAddIter = couldAdd.lower_bound(10 - (cur[1] - '0'));
            if (curAddIter != couldAdd.end()) {
                for (int i = 0; i < cur.length(); ++i) {
                    if (i % 2 == 0) continue;
                    auto& c = cur[i];
                    c = '0' + ((c - '0' + *curAddIter) % 10);
                }
            }
            // 若b为奇数，轮转后还可对偶数位进行操作
            if (b % 2){
                curAddIter = couldAdd.lower_bound(10 - (cur[0] - '0'));
                if (curAddIter != couldAdd.end()) {
                    for (int i = 0; i < cur.length(); ++i) {
                        if (i % 2) continue;
                        auto& c = cur[i];
                        c = '0' + ((c - '0' + *curAddIter) % 10);
                    }
                }
            }
            if (result > cur) result = cur;
            // 计算下次轮转的位置
            movrIdx += b;
            movrIdx %= s.length();
            // 构成循环，则退出
            if (movrIdx == 0) break;
        }
        return result;
    }
};
```

