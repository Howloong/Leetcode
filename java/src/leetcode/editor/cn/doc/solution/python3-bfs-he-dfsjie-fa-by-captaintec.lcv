## 1. 无论是 bfs 还是 dfs，都按先右移，再左移的操作，进行递归(dfs) 或者 进队(bfs)，才能保证能到达目标节点时，步数最少。（直观理解，感觉可以用归纳法证明... -_-#）

> 举个反例：
> 对于测试数据：

* python

```python
[]
3
2
6
```

> 右移 操作在 左移操作前面，返回正确结果`2`，反之返回错误结果 `7`.

## 2. 防止无限递归是关键，forbidden 中加入右移时遍历到的数据

> a == b 时，若x点不可达，则会出现无限递归

## 3. （需仔细理解） forbidden 中 __不能__ 加入左移时遍历到的数据，原因是 因为左移后退回cur-b处时，无法覆盖前进到cur-b再后退到cur-2b的情况。

- 通俗解释：前进去过的地方，后退就没必要再去了，因为前进去过的地方，既可以前进又可以后退。但是后退去过的地方因为只能前进，所以前进还得再去搜索一下，看后退符不符合条件。 （参考[@Eric](https://leetcode-cn.com/u/sucre-4/)大佬的留言）

> 举个例子：
> 对于测试数据

* python

```python
[]
3
1
4
```

> `a = 3, b = 1, x = 4`, 此时左移遍历到的数据 不加到`forbidden`中的遍历顺序为 [0, 3, 6, 2, 9, 5, **5**, 12, 8, 8, 4], 最终的结果4 是由第二个 5（数组中已加粗）左移b=1 得到的，而该5（数组中已加粗）的上一步是由数组中的2 右移得到的
>
> 如果 左移遍历到的数据 加到`forbidden`中， 则遍历顺序中不会出现第二个5，而第一个5 是由 6左移b=1得到的，由于不能同时左移两次，这样就无法到达目标点 x = 4

---

# DFS

* python

```python
class Solution:
    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
        forbidden = set(forbidden)
        self.key = -1
        
        def dfs(num, cnt, back):
            if self.key < 0 and 0 <= num <= 6000:  # # 6000是往右探索的最大值，x最大为2000
                if num == x:  # 第一次遍历到 x时的次数即为结果，暂存结果，不再递归
                    self.key = cnt  
                    return
                if num+a not in forbidden:
                    forbidden.add(num+a)  # 防止无限递归，比如 a = b 时，不加限制，就会出现无限递归
                    dfs(num+a, cnt+1, 0)
                if num-b not in forbidden and back != 1:  # 若back为1说明上次就是往后跳的
                    dfs(num-b, cnt+1, 1)
                
        dfs(0, 0, 0)
        return self.key
```

# BFS

参考某大佬的代码，[这里是链接](https://leetcode-cn.com/problems/minimum-jumps-to-reach-home/solution/python3-bfs-by-lppy/)

* python

```python
class Solution:
    def minimumJumps(self, forbidden: List[int], a: int, b: int, x: int) -> int:
        forbidden = set(forbidden)
        Q = deque()
        Q.append((0, 0, False))
        while Q:
            cur, cnt, used = Q.popleft()
            if cur == x:
                # 第一次到x即最小步数，因为队列后序元素cnt都是大于等于当前cnt的
                return cnt
            if cur + a < 6000 and cur + a not in forbidden:
                # 6000是往右探索的最大值，x最大为2000
                forbidden.add(cur+a)
                Q.append((cur+a, cnt+1, False))
            if not used and cur - b > 0 and cur - b not in forbidden:
                # forbidden.add(cur-b) 
                # 这里不能forbidden，因为后退回cur-b处时，无法覆盖前进到cur-b再后退到cur-2b的情况。
                Q.append((cur-b, cnt+1, True))
        return -1
```

