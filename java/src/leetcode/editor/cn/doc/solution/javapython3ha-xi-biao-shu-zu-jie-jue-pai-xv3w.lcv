# 题目

## 2475. 数组中不等三元组的数目

给你一个下标从 **0** 开始的正整数数组 `nums` 。请你找出并统计满足下述条件的三元组 `(i, j, k)` 的数目：

- `0 <= i < j < k < nums.length`
- `nums[i]`、`nums[j]` 和 `nums[k]` 两两不同 。
  - 换句话说：`nums[i] != nums[j]`、`nums[i] != nums[k]` 且 `nums[j] != nums[k]` 。

返回满足上述条件三元组的数目。

# 题目分析

这道题是要统计 出数组中选出三个完全不同的数组成的三元组个数有多少个。
那么相同的元素其实都可以归为一个类，如示例`[4, 4, 2, 4, 3]`
![image.png](https://pic.leetcode.cn/1686587336-WCoYka-image.png)

其实我们要找出数组中有多少种不同的元素，以及每个元素有多少种。推广到任意一个元素`num`，其能构成的三元组，可以看作：
- 从比它小的`k`个元素中选出一个元素，有**k**种选择；
- 从这个元素的`c`个元素中选出一个`n`，有**c**种选择；
- 从比它大的`n - k - c`个元素中选出一个元素，有**n - k - c**种选择；【`n`为元素总数】

【**三个不同元素构成的组合一定是一个最大值，一个中间值，一个最小值。我们尝试把每个元素都当成中间值，去找到它能够构成的三元组种数**】
因此一种元素`n`，可以贡献的三元组为**kc(n - k - c)**。累加每一种元素的贡献即为结果。
![image.png](https://pic.leetcode.cn/1686587918-cuqpOW-image.png)

# 图解示例

![image.png](https://pic.leetcode.cn/1686589169-IIbiSb-image.png)

# 代码

由于元素最大值为`1000`，因此可以使用一个长度为`1001`的数组来统计每种元素的个数。同时数组也做了排序的功能，依次累加遍历过的元素个数`k`，即为小于当前遍历元素的个数。
同时当k=0【遍历到最小元素，最小元素不可能为三元组中间值】，c=0【元素不存在】，n-c-k=0【遍历到最大元素，最大元素不可能为三元组中间值】，乘积都为`0`，不影响结果。

* []

```java
class Solution {
    public int unequalTriplets(int[] nums) {
        int n = nums.length;            // 元素总数
        int[] counts = new int[1001];   // 统计数组
        for(int num: nums){
            counts[num]++;
        }
        int k = 0;          // 小于当前遍历元素的个数
        int triples = 0;    // 三元组个数
        for(int c: counts){
            triples += k * c * (n - c - k);     // 累加三元组个数
            k += c;     // 累加k值
        }
        return triples;
    }
}
```

* []

```python
class Solution:
    def unequalTriplets(self, nums: List[int]) -> int:
        n = len(nums)           # 元素总数
        counts = [0] * 1001     # 统计数组
        for num in nums:
            counts[num] += 1
        k = 0           # 小于当前遍历元素的个数
        triplets = 0    # 三元组个数
        for c in counts:
            triplets += k * c * (n - c - k) # 累加三元组个数
            k += c  # 累加k值
        return triplets
```

