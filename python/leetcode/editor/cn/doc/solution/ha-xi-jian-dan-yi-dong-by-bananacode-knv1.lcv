> Problem: [828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/description/)

[TOC]

# 解题思路

这个问题可以通过分析每个字符在多少不同的子串中作为唯一字符出现来解决。关键在于确定每个字符上一次出现的位置和下一次出现的位置，以此来计算该字符对总数的贡献。

1.计算每个字符的贡献：
对于字符串 s 中的每个字符 s[i]，找出它上一次出现的位置 left 和下一次出现的位置 right。
s[i] 在 (i - left) * (right - i) 个不同的子串中作为唯一字符出现。

2.累加所有字符的贡献：
对于字符串 s 中的每个字符，计算其贡献并累加。

# 算法复杂度

时间复杂度: O(N * 26)，其中 N 是字符串 s 的长度。对于每个字符，我们需要更新 26 个字母的贡献。
空间复杂度: O(26)，即 O(1)。我们使用了两个长度为 26 的数组，分别存储每个字符的最后位置和贡献。

# (i - left) * (right - i) 解释

这句话的原理基于如何计算一个字符在多少个子字符串中作为唯一字符出现。对于字符串 s 中的某个特定字符 s[i]，我们需要确定其贡献，也就是它在多少个不同的子字符串中作为唯一字符出现。

1.确定边界:

left 表示字符 s[i] 上一次出现的位置（如果没有出现过，则为 -1）。
right 表示字符 s[i] 下一次出现的位置（如果没有出现过，则为字符串的长度 n）。

2.子字符串的选择:

选择 s[i] 为子字符串的起始位置的方法有 i - left 种（即从 left + 1 到 i）。
选择 s[i] 为子字符串的结束位置的方法有 right - i 种（即从 i 到 right - 1）。

3.计算贡献:

因为我们要选择包含 s[i] 并且 s[i] 在其中唯一的子字符串，所以 s[i] 可以在 (i - left) * (right - i) 个不同的子字符串中作为唯一字符出现。

举例说明
假设我们有字符串 "abac"，我们来计算字符 'a' 在位置 2（即第三个字符，0索引）的贡献。

'a' 在位置 2 上一次出现是在位置 0，所以 left = 0。
'a' 在位置 2 下一次出现是在字符串末尾，假设字符串长度为 n，所以 right = n。
对于 'a'，我们可以选择从位置 1 到 2 作为起始位置（2种选择），并且从位置 2 到 n - 1 作为结束位置（n - 2 种选择）。
因此，字符 'a' 在位置 2 的贡献是 2 * (n - 2)。
这种计算方法考虑了所有可能包含特定字符并且该字符在其中唯一的子字符串。通过这种方式，我们可以计算每个字符对总唯一字符数的贡献。

如果某个字符在字符串中出现超过三次，我们仍然可以使用相同的方法来计算其在不同子字符串中作为唯一字符的贡献。关键在于我们关注的是某个特定位置上的字符，而不是字符本身在整个字符串中的所有出现。

对于字符串中的某个特定字符 s[i]，我们需要找到它上一次和下一次出现的位置。这些位置定义了 s[i] 可以作为唯一字符出现的子字符串的边界。无论这个字符在整个字符串中出现了多少次，对于位置 i 的这个字符，我们只关注它相对于 i 的上一个和下一个位置。

计算方法
上一个位置 (left): 字符 s[i] 在位置 i 之前最后一次出现的位置。如果 s[i] 在 i 之前从未出现过，left = -1。

下一个位置 (right): 字符 s[i] 在位置 i 之后下一次出现的位置。如果 s[i] 在 i 之后再也没有出现，right = n，其中 n 是字符串的长度。

贡献计算: 字符 s[i] 的贡献为 (i - left) * (right - i)，即有多少种方式可以选择包含 s[i] 的子字符串的起始和结束位置，使得 s[i] 是这些子字符串中唯一的字符。

例子
考虑字符串 "abaaca" 和位置 i = 3 上的字符 'a'。

'a' 在位置 3 的上一个位置是 2（left = 2）。
'a' 在位置 3 的下一个位置是 5（right = 5）。
对于位置 3 上的 'a'，我们可以选择从位置 3 到 4 作为起始位置（2种选择），并且从位置 3 到 4 作为结束位置（2种选择）。
因此，位置 3 上的 'a' 的贡献是 2 * 2 = 4。
这种方法确保我们正确计算了每个位置上字符的贡献，而不论该字符在整个字符串中出现了多少次。

# Code

* []

```C++
class Solution {
public:
    int uniqueLetterString(string s) {
        int n = s.length();
        vector<int> lastPosition(26, -1); // 记录每个字符上一次出现的位置，初始化为 -1
        vector<int> contribution(26, 0); // 记录每个字符的贡献，初始化为 0
        int result = 0;
        int mod = 1e9 + 7; // 用于处理大数溢出问题

        for (int i = 0; i < n; ++i) {
            int c = s[i] - 'A'; // 将字符转换为索引
            contribution[c] = (i - lastPosition[c]) % mod; // 计算当前字符的贡献
            lastPosition[c] = i; // 更新当前字符的位置
            for (int j = 0; j < 26; ++j) {
                result = (result + contribution[j]) % mod; // 累加所有字符的贡献
            }
        }

        return result;
    }
};

/*

*/
```

