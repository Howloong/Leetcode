**æ–¹æ³•ä¸€ï¼šæ’åº + åˆ†ç±»è®¨è®º + åŒæŒ‡é’ˆ**

æˆ‘ä»¬å…ˆå¯¹æ•°ç»„ $stones$ è¿›è¡Œå‡åºæ’åºï¼Œæ¥ä¸‹æ¥åˆ†åˆ«è€ƒè™‘æœ€å¤§ç§»åŠ¨æ¬¡æ•° $mx$ å’Œæœ€å°ç§»åŠ¨æ¬¡æ•° $mi$ã€‚

å¯¹äºæœ€å¤§ç§»åŠ¨æ¬¡æ•° $mx$ï¼š

ç”±äºæˆ‘ä»¬æ¯ä¸€æ¬¡åªèƒ½é€‰æ‹©å°†ç«¯ç‚¹çŸ³å­ç§»åŠ¨åˆ°æœªå ç”¨ä¸”ä¸æ˜¯ç«¯ç‚¹çŸ³å­çš„ä½ç½®ï¼Œå¦‚æœæˆ‘ä»¬é€‰æ‹© $stones[0]$ ä½œä¸ºç¬¬ä¸€æ¬¡ç§»åŠ¨çš„ç«¯ç‚¹çŸ³å­ï¼Œé‚£ä¹ˆä» $stones[0]$ åˆ° $stones[1]$ ä¹‹é—´çš„æ‰€æœ‰æœªå ç”¨çš„ä½ç½®éƒ½ä¼šè¢«è·³è¿‡ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©ç§»åŠ¨åˆ°æœ€è¿‘çš„ä¸”æœªå ç”¨çš„ä½ç½®ï¼Œæ¥ä¸‹æ¥æ¯ä¸€æ¬¡éƒ½å°†æœ€å·¦ç«¯çš„çŸ³å­ç§»åŠ¨åˆ°æœ€è¿‘çš„ä¸”æœªå ç”¨çš„ä½ç½®ï¼Œé‚£ä¹ˆæœ€å¤šå¯ä»¥ç§»åŠ¨çš„æ¬¡æ•°ä¸º $stones[n - 1] - stones[1] + 1 - (n - 1)$ï¼›åŒç†ï¼Œå¦‚æœæˆ‘ä»¬é€‰æ‹© $stones[n - 1]$ ä½œä¸ºç¬¬ä¸€æ¬¡ç§»åŠ¨çš„ç«¯ç‚¹çŸ³å­ï¼Œé‚£ä¹ˆæœ€å¤šå¯ä»¥ç§»åŠ¨çš„æ¬¡æ•°ä¸º $stones[n - 2] - stones[0] + 1 - (n - 1)$ã€‚å–ä¸¤è€…çš„æœ€å¤§å€¼å³ä¸ºæœ€å¤§ç§»åŠ¨æ¬¡æ•° $mx$ã€‚

å¯¹äºæœ€å°ç§»åŠ¨æ¬¡æ•° $mi$ï¼š

æˆ‘ä»¬ç”¨åŒæŒ‡é’ˆ $i$ å’Œ $j$ æ ‡è¯†ä¸€ä¸ªçª—å£çš„å·¦å³ç«¯ç‚¹ï¼Œè‹¥çª—å£å†…çš„ä½ç½®æ•° $stones[j] - stones[i] + 1 \gt n$ æ—¶ï¼Œæˆ‘ä»¬éœ€è¦ç¼©å°çª—å£ï¼Œå³æŒ‡é’ˆ $i$ å‘å³ç§»åŠ¨ã€‚å¦‚æœæ­¤æ—¶çª—å£ä¸­æœ‰è¿ç»­çš„ $n-1$ ä¸ªçŸ³å­ï¼Œå³æ»¡è¶³ $j - i + 1 = n - 1$ ä¸” $stones[j] - stones[i] + 1 = n - 1$ï¼Œé‚£ä¹ˆæœ€å°‘éœ€è¦ç§»åŠ¨çš„æ¬¡æ•°ä¸º $2$ï¼›å¦åˆ™ï¼Œæˆ‘ä»¬ç”¨ $n$ å‡å»çª—å£å†…çš„çŸ³å­æ•°ï¼Œå¯ä»¥å¾—åˆ°æœ€å°‘éœ€è¦ç§»åŠ¨çš„æ¬¡æ•°ï¼Œå³ $n - (j - i + 1)$ã€‚å–æ‰€æœ‰æƒ…å†µçš„æœ€å°å€¼å³ä¸ºæœ€å°ç§»åŠ¨æ¬¡æ•° $mi$ã€‚

* [sol1-Python3]

```python
class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        mi = n = len(stones)
        mx = max(stones[-1] - stones[1] + 1, stones[-2] - stones[0] + 1) - (n - 1)
        i = 0
        for j, x in enumerate(stones):
            while x - stones[i] + 1 > n:
                i += 1
            if j - i + 1 == n - 1 and x - stones[i] == n - 2:
                mi = min(mi, 2)
            else:
                mi = min(mi, n - (j - i + 1))
        return [mi, mx]
```

* [sol1-Java]

```java
class Solution {
    public int[] numMovesStonesII(int[] stones) {
        Arrays.sort(stones);
        int n = stones.length;
        int mi = n;
        int mx = Math.max(stones[n - 1] - stones[1] + 1, stones[n - 2] - stones[0] + 1) - (n - 1);
        for (int i = 0, j = 0; j < n; ++j) {
            while (stones[j] - stones[i] + 1 > n) {
                ++i;
            }
            if (j - i + 1 == n - 1 && stones[j] - stones[i] == n - 2) {
                mi = Math.min(mi, 2);
            } else {
                mi = Math.min(mi, n - (j - i + 1));
            }
        }
        return new int[] {mi, mx};
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    vector<int> numMovesStonesII(vector<int>& stones) {
        sort(stones.begin(), stones.end());
        int n = stones.size();
        int mi = n;
        int mx = max(stones[n - 1] - stones[1] + 1, stones[n - 2] - stones[0] + 1) - (n - 1);
        for (int i = 0, j = 0; j < n; ++j) {
            while (stones[j] - stones[i] + 1 > n) {
                ++i;
            }
            if (j - i + 1 == n - 1 && stones[j] - stones[i] == n - 2) {
                mi = min(mi, 2);
            } else {
                mi = min(mi, n - (j - i + 1));
            }
        }
        return {mi, mx};
    }
};
```

* [sol1-Go]

```go
func numMovesStonesII(stones []int) []int {
	sort.Ints(stones)
	n := len(stones)
	mi := n
	mx := max(stones[n-1]-stones[1]+1, stones[n-2]-stones[0]+1) - (n - 1)
	i := 0
	for j, x := range stones {
		for x-stones[i]+1 > n {
			i++
		}
		if j-i+1 == n-1 && stones[j]-stones[i] == n-2 {
			mi = min(mi, 2)
		} else {
			mi = min(mi, n-(j-i+1))
		}
	}
	return []int{mi, mx}
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

* [sol1-TypeScript]

```ts
function numMovesStonesII(stones: number[]): number[] {
    stones.sort((a, b) => a - b);
    const n = stones.length;
    let mi = n;
    const mx =
        Math.max(stones[n - 1] - stones[1] + 1, stones[n - 2] - stones[0] + 1) -
        (n - 1);
    for (let i = 0, j = 0; j < n; ++j) {
        while (stones[j] - stones[i] + 1 > n) {
            ++i;
        }
        if (j - i + 1 === n - 1 && stones[j] - stones[i] === n - 2) {
            mi = Math.min(mi, 2);
        } else {
            mi = Math.min(mi, n - (j - i + 1));
        }
    }
    return [mi, mx];
}
```

æ—¶é—´å¤æ‚åº¦ $O(n \times \log n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(\log n)$ã€‚å…¶ä¸­ $n$ ä¸ºæ•°ç»„ $stones$ çš„é•¿åº¦ã€‚

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿è¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿è¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆğŸ˜„~
