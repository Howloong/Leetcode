> [2594. 修车的最少时间](https://leetcode.cn/problems/minimum-time-to-repair-cars/description/) - [第 100 场双周赛](https://leetcode.cn/contest/biweekly-contest-100/)

# 思路

看到这题熟悉而陌生，原来是双周赛最后一题，当时没写出，这次写出来了，总结一下；

一开始看错题，是求最短总时长，觉得要用动态规划，但发现原来是同时开始求最短时，题目故意写上：

> 注意：所有机械工可以同时修理汽车。

明明最好理解的词是“必须”写“可以”就障眼法了，但第四题有障眼法也很正常，那么这种题很可能就是二分答案了，确认能否二分答案的题目，主要确认两点：

1. **有清晰的二分条件判断**：能理清楚“同时修理”这四个字就能知道，题目可以转化为，如果给到一个固定时间问全部工人尽可能在时间内能修理的汽车总和是多少，这个求解明显并不难，因为每个工人可以独立工作，所以每个工人都算一次并累加即可。那么如果 t 时间内总修理量如果大于要求，可以减少时间尽可能接近目标修理量，反之增加时间提高修理量，而如果能确认最大时间值那么就可以二分；

2. **合理的时间复杂度度**：有些题目二分有可能超时，是坑，为了避免，我们还需要判断计算量是多少，正常情况下 $O(nlogm)$ 这种情况是不会出现问题的，因为题目不能写死，正常把输入条件挨个排个序也是不会超时，所以关键看 $logm$ 有多大，当前 n 已经是 $10^5$ 的情况下，实际留给我们的操作空间不大于 $10^2$ ，m 大概就是 2 的 100 次方的天文数字，所以就算最坏情况假设最慢的人全干全部车，也不会超时，而且题目放水了，所以只要二分答案不会扣 5 分钟， $n=10^5$ 也限制了题目自己难度，不过也没办法，题目需要给我们数组，$10^6$ 的数组也没办法提高多少难度，但保险而言“合理的最坏”还是搞上，那么可以有这几种选择，假设每个人都均分到一个最少量，那么最慢是谁，就按这个为最坏结果显得比较合理。假设全部给最快的那几个人均分，总时长是多少。但那种都好，最差也不会超时甚至可以直接用 64 位最大整数作为最大值也无妨；

写到这想起某个大佬说过，如果题目里面有“最大”同又有“最小”这样的字眼或者含义，最大同时求最小值，最小同时求最大值，很可能也是二分；

# Code

* []

```Python
class Solution:
    def repairCars(self, ranks: List[int], cars: int) -> int:
        # 合理最坏情况：每个人至少均分到 n 辆车情况下，至少需要 m 分钟才能全部修完
        n = len(ranks)
        m = max(ranks) * (ceil(cars / n) ** 2)


        # 无技巧直接计算 - 252ms
        # def maximumCars(t: int) -> bool:
        #     return sum(floor(sqrt(t / rank)) for rank in ranks) >= cars
        
        
        # 剪枝减少循环量 - 56ms
        # 剪枝一：合并相同 rank 值减少循环次数
        # 剪枝二：当前修理车辆超过 cars 就不需要继续统计
        # 加速技巧：sqrt函数等价**0.5，floor函数等价int()
        counts = Counter(ranks)
        def maximumCars(t: int) -> bool:
            num = 0
            for rank,cnt in counts.items():
                num += cnt * int((t / rank) ** 0.5)
                if num >= cars: return True
            return False


        # 二分答案查找那个时间可以刚好维修完 cars
        left, right = 1, m
        while left < right:
            mid = (left + right) >> 1
            if maximumCars(mid): right = mid
            else: left = mid + 1
        return right
```

* []

```java
/*
解题核心，二分解题
如果采用动态规划，由于cars数量太大，很难采用类似背包的方案。
采用枚举更为合适，我们假设当前只提供一个固定时间给每一个维修厂，那么在这个统一的固定时间内，一个工厂能维修的最多汽车数是固定的，例如现在我们设置只提供4个时间给一个维修值是1的厂，这个厂就最多只能修2辆，计算过程就是逆计算工厂维修能力，维修时间 = 维修值 * 车辆数 * 车辆数，逆求一下即可。那么当我们给固定值全部的工厂，将得到一个维修车辆总数。如果这个总量比题目的多，证明我们时间给多了，减少即可，那么这个时间点从1开始枚举到一个很大的数即可，整体是线性的，固可以二分。

优化点1：优化二分的初始上限，虽然这个对结果影响不大，因为二分情况下就是少一两个循环，而且Math.floor()对int有保护机制，基本不会出错，但如果有其他方案比直接计算更少的时间，那么就会出现总和大于32整数的情况，需要规避，我们就设置全部车辆都给最低的一个处理即可。另外一个规避方案就是把car放入计算过程中去减，少于0即返回

优化点2：由于大部分的用例rank[i]远小于rank的长度，必然存在重复，用一个map记录去重，就可以大幅减少每次for的次数
*/
class Solution {
    public long repairCars(int[] ranks, int cars) {
        int max = 0;
        for (int i = 0; i < ranks.length; i++) {
            if (max < ranks[i]) max = ranks[i];
        }

        int[] map = new int[max + 1];
        int[] list = new int[map.length + 1];

        for (int i = 0; i < ranks.length; i++) {
            if (map[ranks[i]] > 0) map[ranks[i]]++;
            else {
                map[ranks[i]]++;
                list[++list[0]] = ranks[i];
            }
        }

        long high = ranks[0], low = 1, ans = 1, mid;
        for (int i = 1; i <= list[0]; i++) {
            if (high > list[i]) high = list[i];
        }

        high = high * cars * cars;

        while (low <= high) {
            mid = (low + high) >> 1;
            if (check(list, map, mid, cars)) {
                ans = mid;
                high = mid - 1;
            } else low = mid + 1;
        }

        return ans;
    }

    public boolean check(int[] list, int[] map, long time, int total) {
        for (int i = 1; i <= list[0]; i++) {
            total -= Math.floor(Math.sqrt(time / list[i])) * map[list[i]];
            if (total <= 0) return true;
        }
        return total <= 0;
    }

}
```

![image.png](https://pic.leetcode.cn/1694069447-pgVhXJ-image.png)

## java 知识点

Math.floor()存在一定的int保护机制，原理是浮点值转int时不会出现越界，最后一个硬转int会出现越界，数值不正确

* []

```java
System.out.println((int)Math.floor(1e10)); //
System.out.println((int)Math.floor(10000000000l));
System.out.println((int)1e10);
System.out.println((int)10000000000l);
```

# 完

