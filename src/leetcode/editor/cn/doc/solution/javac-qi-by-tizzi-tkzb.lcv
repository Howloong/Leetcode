## 解法一：前缀和

对于每个位置将其他小球放置到该位置$i$等于左边和右边所有的$1$移动到该位置$i$的总步数之和。定义$left[i]$代表左边所有的$1$移动到位置i需要的步数，定义$cnt$为$[1,i - 1]$中1的个数，那么对于当前$i$位置$left[i] = cnt + left[i - 1]$。更新完$left[i]$后更新cnt继续遍历。同理可以定义$right[i]$代表$i$右边所有的1移动到该位置花费的步数。

![图片.png](https://pic.leetcode.cn/1669940127-xTFKdU-%E5%9B%BE%E7%89%87.png)

- 时间复杂度：$O(n)$
- 空间复杂度：$O(n)$

* []

```java
class Solution {
    public int[] minOperations(String boxes) {
        int n = boxes.length();
        char[] arr = (" " + boxes).toCharArray();
        int[] left = new int[n + 5], right = new int[n + 5], ans = new int[n];
        int cnt1 = 0, cnt2 = 0;
        for (int i = 1; i <= n; i++) {
            left[i] = cnt1 + left[i - 1];
            cnt1 += (arr[i] - '0'); 
            right[n - i + 1] = cnt2 + right[n - i + 2];
            cnt2 += (arr[n - i + 1] - '0');
        } 
        for (int i = 1; i <= n; i++) ans[i - 1] = left[i] + right[i];
        return ans;
    }
}
```

* []

```cpp
class Solution {
public:
    vector<int> minOperations(string boxes) {
        int n = boxes.length(); 
        vector<int> left(n + 5, 0), right(n + 5, 0), ans(n, 0);
        int cnt1 = 0, cnt2 = 0;
        for (int i = 1; i <= n; i++) {
            left[i] = cnt1 + left[i - 1];
            cnt1 += (boxes[i - 1] - '0'); 
            right[n - i + 1] = cnt2 + right[n - i + 2];
            cnt2 += (boxes[n - i] - '0');
        } 
        for (int i = 1; i <= n; i++) ans[i - 1] = left[i] + right[i];
        return ans;    
    }
};
```

## 解法二：前缀和优化

在计算答案的时候再计算left前缀和的值。首先计算出解法一中right[1]的结果保存在right中，在计算答案的时候更新left和right即可。<br><br>

- 时间复杂度：$O(n)$
- 空间复杂度：$O(1)$

* []

```java
class Solution {
    public int[] minOperations(String boxes) {
        int n = boxes.length();
        char[] arr = (" " + boxes).toCharArray();
        int left = 0, right = 0, cnt1 = 0, cnt2 = 0; 
        int[] ans = new int[n];
        for (int i = n; i >= 1; i--) { 
            right += cnt2;
            cnt2 += arr[i] - '0';
        } 
        for (int i = 1; i <= n; i++, left += cnt1, right -= cnt2) {
            ans[i - 1] = left + right; 
            cnt1 += arr[i] - '0'; 
            cnt2 -= arr[i] - '0'; 
        }
        return ans;
    }
}
```

* []

```cpp
class Solution {
public:
    vector<int> minOperations(string boxes) {
        int n = boxes.length(); 
        int left = 0, right = 0, cnt1 = 0, cnt2 = 0; 
        vector<int> ans(n);
        for (int i = n; i >= 1; i--) { 
            right += cnt2;
            cnt2 += boxes[i - 1] - '0';
        } 
        for (int i = 1; i <= n; i++, left += cnt1, right -= cnt2) {
            ans[i - 1] = left + right; 
            cnt1 += boxes[i - 1] - '0'; 
            cnt2 -= boxes[i - 1] - '0'; 
        }
        return ans; 
    }
};
```

- 或者两次遍历进行答案更新。

* []

```java
class Solution {
    public int[] minOperations(String boxes) {
        int n = boxes.length();
        char[] arr = (" " + boxes).toCharArray();
        int left = 0, cnt1 = 0, cnt2 = 0; 
        int[] ans = new int[n];
        for (int i = n; i >= 1; i--) { 
            ans[i - 1] += (i < n ? ans[i] : 0) +  cnt2; 
            cnt2 += arr[i] - '0';
        } 
        for (int i = 1; i <= n; i++, left += cnt1) {
            ans[i - 1] += left; 
            cnt1 += arr[i] - '0';  
        }
        return ans;
    }
}
```

--- 

如果有问题,欢迎评论区交流, 如果有帮助到你，请给题解点个赞和收藏哈~~~
